{"ast":null,"code":"import _objectSpread from \"/Users/kevin/website/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/Users/kevin/website/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _get from \"/Users/kevin/website/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/kevin/website/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/kevin/website/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/kevin/website/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"/Users/kevin/website/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/kevin/website/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// src/Animated.ts\nimport { defineHidden } from \"@react-spring/shared\";\nvar $node = Symbol.for(\"Animated:node\");\nvar isAnimated = function isAnimated(value) {\n  return !!value && value[$node] === value;\n};\nvar getAnimated = function getAnimated(owner) {\n  return owner && owner[$node];\n};\nvar setAnimated = function setAnimated(owner, node) {\n  return defineHidden(owner, $node, node);\n};\nvar getPayload = function getPayload(owner) {\n  return owner && owner[$node] && owner[$node].getPayload();\n};\nvar Animated = /*#__PURE__*/function () {\n  function Animated() {\n    _classCallCheck(this, Animated);\n    setAnimated(this, this);\n  }\n  /** Get every `AnimatedValue` used by this node. */\n  _createClass(Animated, [{\n    key: \"getPayload\",\n    value: function getPayload() {\n      return this.payload || [];\n    }\n  }]);\n  return Animated;\n}();\n\n// src/AnimatedValue.ts\nimport { is } from \"@react-spring/shared\";\nvar AnimatedValue = /*#__PURE__*/function (_Animated) {\n  _inherits(AnimatedValue, _Animated);\n  var _super = _createSuper(AnimatedValue);\n  function AnimatedValue(_value) {\n    var _this;\n    _classCallCheck(this, AnimatedValue);\n    _this = _super.call(this);\n    _this._value = _value;\n    _this.done = true;\n    _this.durationProgress = 0;\n    if (is.num(_this._value)) {\n      _this.lastPosition = _this._value;\n    }\n    return _this;\n  }\n  /** @internal */\n  _createClass(AnimatedValue, [{\n    key: \"getPayload\",\n    value: function getPayload() {\n      return [this];\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this._value;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value, step) {\n      if (is.num(value)) {\n        this.lastPosition = value;\n        if (step) {\n          value = Math.round(value / step) * step;\n          if (this.done) {\n            this.lastPosition = value;\n          }\n        }\n      }\n      if (this._value === value) {\n        return false;\n      }\n      this._value = value;\n      return true;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var done = this.done;\n      this.done = false;\n      if (is.num(this._value)) {\n        this.elapsedTime = 0;\n        this.durationProgress = 0;\n        this.lastPosition = this._value;\n        if (done) this.lastVelocity = null;\n        this.v0 = null;\n      }\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      return new AnimatedValue(value);\n    }\n  }]);\n  return AnimatedValue;\n}(Animated);\n\n// src/AnimatedString.ts\nimport { is as is2, createInterpolator } from \"@react-spring/shared\";\nvar AnimatedString = /*#__PURE__*/function (_AnimatedValue) {\n  _inherits(AnimatedString, _AnimatedValue);\n  var _super2 = _createSuper(AnimatedString);\n  function AnimatedString(value) {\n    var _this2;\n    _classCallCheck(this, AnimatedString);\n    _this2 = _super2.call(this, 0);\n    _this2._string = null;\n    _this2._toString = createInterpolator({\n      output: [value, value]\n    });\n    return _this2;\n  }\n  /** @internal */\n  _createClass(AnimatedString, [{\n    key: \"getValue\",\n    value: function getValue() {\n      var value = this._string;\n      return value == null ? this._string = this._toString(this._value) : value;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(value) {\n      if (is2.str(value)) {\n        if (value == this._string) {\n          return false;\n        }\n        this._string = value;\n        this._value = 1;\n      } else if (_get(_getPrototypeOf(AnimatedString.prototype), \"setValue\", this).call(this, value)) {\n        this._string = null;\n      } else {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(goal) {\n      if (goal) {\n        this._toString = createInterpolator({\n          output: [this.getValue(), goal]\n        });\n      }\n      this._value = 0;\n      _get(_getPrototypeOf(AnimatedString.prototype), \"reset\", this).call(this);\n    }\n  }], [{\n    key: \"create\",\n    value: function create(value) {\n      return new AnimatedString(value);\n    }\n  }]);\n  return AnimatedString;\n}(AnimatedValue);\n\n// src/AnimatedArray.ts\nimport { isAnimatedString } from \"@react-spring/shared\";\n\n// src/AnimatedObject.ts\nimport { each, eachProp, getFluidValue, hasFluidValue } from \"@react-spring/shared\";\n\n// src/context.ts\nvar TreeContext = {\n  dependencies: null\n};\n\n// src/AnimatedObject.ts\nvar AnimatedObject = /*#__PURE__*/function (_Animated2) {\n  _inherits(AnimatedObject, _Animated2);\n  var _super3 = _createSuper(AnimatedObject);\n  function AnimatedObject(source) {\n    var _this3;\n    _classCallCheck(this, AnimatedObject);\n    _this3 = _super3.call(this);\n    _this3.source = source;\n    _this3.setValue(source);\n    return _this3;\n  }\n  _createClass(AnimatedObject, [{\n    key: \"getValue\",\n    value: function getValue(animated) {\n      var values = {};\n      eachProp(this.source, function (source, key) {\n        if (isAnimated(source)) {\n          values[key] = source.getValue(animated);\n        } else if (hasFluidValue(source)) {\n          values[key] = getFluidValue(source);\n        } else if (!animated) {\n          values[key] = source;\n        }\n      });\n      return values;\n    }\n    /** Replace the raw object data */\n  }, {\n    key: \"setValue\",\n    value: function setValue(source) {\n      this.source = source;\n      this.payload = this._makePayload(source);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this.payload) {\n        each(this.payload, function (node) {\n          return node.reset();\n        });\n      }\n    }\n    /** Create a payload set. */\n  }, {\n    key: \"_makePayload\",\n    value: function _makePayload(source) {\n      if (source) {\n        var payload = /* @__PURE__ */new Set();\n        eachProp(source, this._addToPayload, payload);\n        return Array.from(payload);\n      }\n    }\n    /** Add to a payload set. */\n  }, {\n    key: \"_addToPayload\",\n    value: function _addToPayload(source) {\n      var _this4 = this;\n      if (TreeContext.dependencies && hasFluidValue(source)) {\n        TreeContext.dependencies.add(source);\n      }\n      var payload = getPayload(source);\n      if (payload) {\n        each(payload, function (node) {\n          return _this4.add(node);\n        });\n      }\n    }\n  }]);\n  return AnimatedObject;\n}(Animated);\n\n// src/AnimatedArray.ts\nvar AnimatedArray = /*#__PURE__*/function (_AnimatedObject) {\n  _inherits(AnimatedArray, _AnimatedObject);\n  var _super4 = _createSuper(AnimatedArray);\n  function AnimatedArray(source) {\n    _classCallCheck(this, AnimatedArray);\n    return _super4.call(this, source);\n  }\n  /** @internal */\n  _createClass(AnimatedArray, [{\n    key: \"getValue\",\n    value: function getValue() {\n      return this.source.map(function (node) {\n        return node.getValue();\n      });\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(source) {\n      var payload = this.getPayload();\n      if (source.length == payload.length) {\n        return payload.map(function (node, i) {\n          return node.setValue(source[i]);\n        }).some(Boolean);\n      }\n      _get(_getPrototypeOf(AnimatedArray.prototype), \"setValue\", this).call(this, source.map(makeAnimated));\n      return true;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(source) {\n      return new AnimatedArray(source);\n    }\n  }]);\n  return AnimatedArray;\n}(AnimatedObject);\nfunction makeAnimated(value) {\n  var nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;\n  return nodeType.create(value);\n}\n\n// src/getAnimatedType.ts\nimport { is as is3, isAnimatedString as isAnimatedString2 } from \"@react-spring/shared\";\nfunction getAnimatedType(value) {\n  var parentNode = getAnimated(value);\n  return parentNode ? parentNode.constructor : is3.arr(value) ? AnimatedArray : isAnimatedString2(value) ? AnimatedString : AnimatedValue;\n}\n\n// src/createHost.ts\nimport { is as is5, eachProp as eachProp2 } from \"@react-spring/shared\";\n\n// src/withAnimated.tsx\nimport * as React from \"react\";\nimport { forwardRef, useRef, useCallback, useEffect } from \"react\";\nimport { is as is4, each as each2, raf, useForceUpdate, useOnce, addFluidObserver, removeFluidObserver, useIsomorphicLayoutEffect } from \"@react-spring/shared\";\nvar withAnimated = function withAnimated(Component, host) {\n  var hasInstance =\n  // Function components must use \"forwardRef\" to avoid being\n  // re-rendered on every animation frame.\n  !is4.fun(Component) || Component.prototype && Component.prototype.isReactComponent;\n  return forwardRef(function (givenProps, givenRef) {\n    var instanceRef = useRef(null);\n    var ref = hasInstance &&\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useCallback(function (value) {\n      instanceRef.current = updateRef(givenRef, value);\n    }, [givenRef]);\n    var _getAnimatedState = getAnimatedState(givenProps, host),\n      _getAnimatedState2 = _slicedToArray(_getAnimatedState, 2),\n      props = _getAnimatedState2[0],\n      deps = _getAnimatedState2[1];\n    var forceUpdate = useForceUpdate();\n    var callback = function callback() {\n      var instance = instanceRef.current;\n      if (hasInstance && !instance) {\n        return;\n      }\n      var didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    };\n    var observer = new PropsObserver(callback, deps);\n    var observerRef = useRef();\n    useIsomorphicLayoutEffect(function () {\n      observerRef.current = observer;\n      each2(deps, function (dep) {\n        return addFluidObserver(dep, observer);\n      });\n      return function () {\n        if (observerRef.current) {\n          each2(observerRef.current.deps, function (dep) {\n            return removeFluidObserver(dep, observerRef.current);\n          });\n          raf.cancel(observerRef.current.update);\n        }\n      };\n    });\n    useEffect(callback, []);\n    useOnce(function () {\n      return function () {\n        var observer2 = observerRef.current;\n        each2(observer2.deps, function (dep) {\n          return removeFluidObserver(dep, observer2);\n        });\n      };\n    });\n    var usedProps = host.getComponentProps(props.getValue());\n    return /* @__PURE__ */React.createElement(Component, _objectSpread(_objectSpread({}, usedProps), {}, {\n      ref: ref\n    }));\n  });\n};\nvar PropsObserver = /*#__PURE__*/function () {\n  function PropsObserver(update, deps) {\n    _classCallCheck(this, PropsObserver);\n    this.update = update;\n    this.deps = deps;\n  }\n  _createClass(PropsObserver, [{\n    key: \"eventObserved\",\n    value: function eventObserved(event) {\n      if (event.type == \"change\") {\n        raf.write(this.update);\n      }\n    }\n  }]);\n  return PropsObserver;\n}();\nfunction getAnimatedState(props, host) {\n  var dependencies = /* @__PURE__ */new Set();\n  TreeContext.dependencies = dependencies;\n  if (props.style) props = _objectSpread(_objectSpread({}, props), {}, {\n    style: host.createAnimatedStyle(props.style)\n  });\n  props = new AnimatedObject(props);\n  TreeContext.dependencies = null;\n  return [props, dependencies];\n}\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (is4.fun(ref)) ref(value);else ref.current = value;\n  }\n  return value;\n}\n\n// src/createHost.ts\nvar cacheKey = Symbol.for(\"AnimatedComponent\");\nvar createHost = function createHost(components) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref$applyAnimatedVal = _ref.applyAnimatedValues,\n    applyAnimatedValues = _ref$applyAnimatedVal === void 0 ? function () {\n      return false;\n    } : _ref$applyAnimatedVal,\n    _ref$createAnimatedSt = _ref.createAnimatedStyle,\n    createAnimatedStyle = _ref$createAnimatedSt === void 0 ? function (style) {\n      return new AnimatedObject(style);\n    } : _ref$createAnimatedSt,\n    _ref$getComponentProp = _ref.getComponentProps,\n    getComponentProps = _ref$getComponentProp === void 0 ? function (props) {\n      return props;\n    } : _ref$getComponentProp;\n  var hostConfig = {\n    applyAnimatedValues: applyAnimatedValues,\n    createAnimatedStyle: createAnimatedStyle,\n    getComponentProps: getComponentProps\n  };\n  var animated = function animated(Component) {\n    var displayName = getDisplayName(Component) || \"Anonymous\";\n    if (is5.str(Component)) {\n      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n    Component.displayName = \"Animated(\".concat(displayName, \")\");\n    return Component;\n  };\n  eachProp2(components, function (Component, key) {\n    if (is5.arr(components)) {\n      key = getDisplayName(Component);\n    }\n    animated[key] = animated(Component);\n  });\n  return {\n    animated: animated\n  };\n};\nvar getDisplayName = function getDisplayName(arg) {\n  return is5.str(arg) ? arg : arg && is5.str(arg.displayName) ? arg.displayName : is5.fun(arg) && arg.name || null;\n};\nexport { Animated, AnimatedArray, AnimatedObject, AnimatedString, AnimatedValue, createHost, getAnimated, getAnimatedType, getPayload, isAnimated, setAnimated };","map":{"version":3,"names":["defineHidden","$node","Symbol","for","isAnimated","value","getAnimated","owner","setAnimated","node","getPayload","Animated","_classCallCheck","_createClass","key","payload","is","AnimatedValue","_Animated","_inherits","_super","_createSuper","_value","_this","call","done","durationProgress","num","lastPosition","getValue","setValue","step","Math","round","reset","elapsedTime","lastVelocity","v0","create","is2","createInterpolator","AnimatedString","_AnimatedValue","_super2","_this2","_string","_toString","output","str","_get","_getPrototypeOf","prototype","goal","isAnimatedString","each","eachProp","getFluidValue","hasFluidValue","TreeContext","dependencies","AnimatedObject","_Animated2","_super3","source","_this3","animated","values","_makePayload","Set","_addToPayload","Array","from","_this4","add","AnimatedArray","_AnimatedObject","_super4","map","length","i","some","Boolean","makeAnimated","nodeType","is3","isAnimatedString2","getAnimatedType","parentNode","constructor","arr","is5","eachProp2","React","forwardRef","useRef","useCallback","useEffect","is4","each2","raf","useForceUpdate","useOnce","addFluidObserver","removeFluidObserver","useIsomorphicLayoutEffect","withAnimated","Component","host","hasInstance","fun","isReactComponent","givenProps","givenRef","instanceRef","ref","current","updateRef","_getAnimatedState","getAnimatedState","_getAnimatedState2","_slicedToArray","props","deps","forceUpdate","callback","instance","didUpdate","applyAnimatedValues","observer","PropsObserver","observerRef","dep","cancel","update","observer2","usedProps","getComponentProps","createElement","_objectSpread","eventObserved","event","type","write","style","createAnimatedStyle","cacheKey","createHost","components","_ref","arguments","undefined","_ref$applyAnimatedVal","_ref$createAnimatedSt","_ref$getComponentProp","hostConfig","displayName","getDisplayName","concat","arg","name"],"sources":["/Users/kevin/website/node_modules/@react-spring/animated/src/Animated.ts","/Users/kevin/website/node_modules/@react-spring/animated/src/AnimatedValue.ts","/Users/kevin/website/node_modules/@react-spring/animated/src/AnimatedString.ts","/Users/kevin/website/node_modules/@react-spring/animated/src/AnimatedArray.ts","/Users/kevin/website/node_modules/@react-spring/animated/src/AnimatedObject.ts","/Users/kevin/website/node_modules/@react-spring/animated/src/context.ts","/Users/kevin/website/node_modules/@react-spring/animated/src/getAnimatedType.ts","/Users/kevin/website/node_modules/@react-spring/animated/src/createHost.ts","/Users/kevin/website/node_modules/@react-spring/animated/src/withAnimated.tsx"],"sourcesContent":["import { defineHidden } from '@react-spring/shared'\nimport { AnimatedValue } from './AnimatedValue'\n\nconst $node: any = Symbol.for('Animated:node')\n\nexport const isAnimated = <T = any>(value: any): value is Animated<T> =>\n  !!value && value[$node] === value\n\n/** Get the owner's `Animated` node. */\nexport const getAnimated = <T = any>(owner: any): Animated<T> | undefined =>\n  owner && owner[$node]\n\n/** Set the owner's `Animated` node. */\nexport const setAnimated = (owner: any, node: Animated) =>\n  defineHidden(owner, $node, node)\n\n/** Get every `AnimatedValue` in the owner's `Animated` node. */\nexport const getPayload = (owner: any): AnimatedValue[] | undefined =>\n  owner && owner[$node] && owner[$node].getPayload()\n\nexport abstract class Animated<T = any> {\n  /** The cache of animated values */\n  protected payload?: Payload\n\n  constructor() {\n    // This makes \"isAnimated\" return true.\n    setAnimated(this, this)\n  }\n\n  /** Get the current value. Pass `true` for only animated values. */\n  abstract getValue(animated?: boolean): T\n\n  /** Set the current value. Returns `true` if the value changed. */\n  abstract setValue(value: T): boolean | void\n\n  /** Reset any animation state. */\n  abstract reset(goal?: T): void\n\n  /** Get every `AnimatedValue` used by this node. */\n  getPayload(): Payload {\n    return this.payload || []\n  }\n}\n\nexport type Payload = readonly AnimatedValue[]\n","import { is } from '@react-spring/shared'\nimport { Animated, Payload } from './Animated'\n\n/** An animated number or a native attribute value */\nexport class AnimatedValue<T = any> extends Animated {\n  done = true\n  elapsedTime!: number\n  lastPosition!: number\n  lastVelocity?: number | null\n  v0?: number | null\n  durationProgress = 0\n\n  constructor(protected _value: T) {\n    super()\n    if (is.num(this._value)) {\n      this.lastPosition = this._value\n    }\n  }\n\n  /** @internal */\n  static create(value: any) {\n    return new AnimatedValue(value)\n  }\n\n  getPayload(): Payload {\n    return [this]\n  }\n\n  getValue() {\n    return this._value\n  }\n\n  setValue(value: T, step?: number) {\n    if (is.num(value)) {\n      this.lastPosition = value\n      if (step) {\n        value = (Math.round(value / step) * step) as any\n        if (this.done) {\n          this.lastPosition = value as any\n        }\n      }\n    }\n    if (this._value === value) {\n      return false\n    }\n    this._value = value\n    return true\n  }\n\n  reset() {\n    const { done } = this\n    this.done = false\n    if (is.num(this._value)) {\n      this.elapsedTime = 0\n      this.durationProgress = 0\n      this.lastPosition = this._value\n      if (done) this.lastVelocity = null\n      this.v0 = null\n    }\n  }\n}\n","import { AnimatedValue } from './AnimatedValue'\nimport { is, createInterpolator } from '@react-spring/shared'\n\ntype Value = string | number\n\nexport class AnimatedString extends AnimatedValue<Value> {\n  protected declare _value: number\n  protected _string: string | null = null\n  protected _toString: (input: number) => string\n\n  constructor(value: string) {\n    super(0)\n    this._toString = createInterpolator({\n      output: [value, value],\n    })\n  }\n\n  /** @internal */\n  static create(value: string) {\n    return new AnimatedString(value)\n  }\n\n  getValue() {\n    const value = this._string\n    return value == null ? (this._string = this._toString(this._value)) : value\n  }\n\n  setValue(value: Value) {\n    if (is.str(value)) {\n      if (value == this._string) {\n        return false\n      }\n      this._string = value\n      this._value = 1\n    } else if (super.setValue(value)) {\n      this._string = null\n    } else {\n      return false\n    }\n    return true\n  }\n\n  reset(goal?: string) {\n    if (goal) {\n      this._toString = createInterpolator({\n        output: [this.getValue(), goal],\n      })\n    }\n    this._value = 0\n    super.reset()\n  }\n}\n","import { isAnimatedString } from '@react-spring/shared'\nimport { AnimatedObject } from './AnimatedObject'\nimport { AnimatedString } from './AnimatedString'\nimport { AnimatedValue } from './AnimatedValue'\n\ntype Value = number | string\ntype Source = AnimatedValue<Value>[]\n\n/** An array of animated nodes */\nexport class AnimatedArray<\n  T extends ReadonlyArray<Value> = Value[]\n> extends AnimatedObject {\n  protected declare source: Source\n  constructor(source: T) {\n    super(source)\n  }\n\n  /** @internal */\n  static create<T extends ReadonlyArray<Value>>(source: T) {\n    return new AnimatedArray(source)\n  }\n\n  getValue(): T {\n    return this.source.map(node => node.getValue()) as any\n  }\n\n  setValue(source: T) {\n    const payload = this.getPayload()\n    // Reuse the payload when lengths are equal.\n    if (source.length == payload.length) {\n      return payload.map((node, i) => node.setValue(source[i])).some(Boolean)\n    }\n    // Remake the payload when length changes.\n    super.setValue(source.map(makeAnimated))\n    return true\n  }\n}\n\nfunction makeAnimated(value: any) {\n  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue\n  return nodeType.create(value)\n}\n","import { Lookup } from '@react-spring/types'\nimport {\n  each,\n  eachProp,\n  getFluidValue,\n  hasFluidValue,\n} from '@react-spring/shared'\nimport { Animated, isAnimated, getPayload } from './Animated'\nimport { AnimatedValue } from './AnimatedValue'\nimport { TreeContext } from './context'\n\n/** An object containing `Animated` nodes */\nexport class AnimatedObject extends Animated {\n  constructor(protected source: Lookup) {\n    super()\n    this.setValue(source)\n  }\n\n  getValue(animated?: boolean) {\n    const values: Lookup = {}\n    eachProp(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated)\n      } else if (hasFluidValue(source)) {\n        values[key] = getFluidValue(source)\n      } else if (!animated) {\n        values[key] = source\n      }\n    })\n    return values\n  }\n\n  /** Replace the raw object data */\n  setValue(source: Lookup) {\n    this.source = source\n    this.payload = this._makePayload(source)\n  }\n\n  reset() {\n    if (this.payload) {\n      each(this.payload, node => node.reset())\n    }\n  }\n\n  /** Create a payload set. */\n  protected _makePayload(source: Lookup) {\n    if (source) {\n      const payload = new Set<AnimatedValue>()\n      eachProp(source, this._addToPayload, payload)\n      return Array.from(payload)\n    }\n  }\n\n  /** Add to a payload set. */\n  protected _addToPayload(this: Set<AnimatedValue>, source: any) {\n    if (TreeContext.dependencies && hasFluidValue(source)) {\n      TreeContext.dependencies.add(source)\n    }\n    const payload = getPayload(source)\n    if (payload) {\n      each(payload, node => this.add(node))\n    }\n  }\n}\n","import { FluidValue } from '@react-spring/shared'\n\nexport type TreeContext = {\n  /**\n   * Any animated values found when updating the payload of an `AnimatedObject`\n   * are also added to this `Set` to be observed by an animated component.\n   */\n  dependencies: Set<FluidValue> | null\n}\n\nexport const TreeContext: TreeContext = { dependencies: null }\n","import { is, isAnimatedString } from '@react-spring/shared'\nimport { AnimatedType } from './types'\nimport { AnimatedArray } from './AnimatedArray'\nimport { AnimatedString } from './AnimatedString'\nimport { AnimatedValue } from './AnimatedValue'\nimport { getAnimated } from './Animated'\n\n/** Return the `Animated` node constructor for a given value */\nexport function getAnimatedType(value: any): AnimatedType {\n  const parentNode = getAnimated(value)\n  return parentNode\n    ? (parentNode.constructor as any)\n    : is.arr(value)\n    ? AnimatedArray\n    : isAnimatedString(value)\n    ? AnimatedString\n    : AnimatedValue\n}\n","import { Lookup } from '@react-spring/types'\nimport { is, eachProp } from '@react-spring/shared'\nimport { AnimatableComponent, withAnimated } from './withAnimated'\nimport { Animated } from './Animated'\nimport { AnimatedObject } from './AnimatedObject'\n\nexport interface HostConfig {\n  /** Provide custom logic for native updates */\n  applyAnimatedValues: (node: any, props: Lookup) => boolean | void\n  /** Wrap the `style` prop with an animated node */\n  createAnimatedStyle: (style: Lookup) => Animated\n  /** Intercept props before they're passed to an animated component */\n  getComponentProps: (props: Lookup) => typeof props\n}\n\n// A stub type that gets replaced by @react-spring/web and others.\ntype WithAnimated = {\n  (Component: AnimatableComponent): any\n  [key: string]: any\n}\n\n// For storing the animated version on the original component\nconst cacheKey = Symbol.for('AnimatedComponent')\n\nexport const createHost = (\n  components: AnimatableComponent[] | { [key: string]: AnimatableComponent },\n  {\n    applyAnimatedValues = () => false,\n    createAnimatedStyle = style => new AnimatedObject(style),\n    getComponentProps = props => props,\n  }: Partial<HostConfig> = {}\n) => {\n  const hostConfig: HostConfig = {\n    applyAnimatedValues,\n    createAnimatedStyle,\n    getComponentProps,\n  }\n\n  const animated: WithAnimated = (Component: any) => {\n    const displayName = getDisplayName(Component) || 'Anonymous'\n\n    if (is.str(Component)) {\n      Component =\n        animated[Component] ||\n        (animated[Component] = withAnimated(Component, hostConfig))\n    } else {\n      Component =\n        Component[cacheKey] ||\n        (Component[cacheKey] = withAnimated(Component, hostConfig))\n    }\n\n    Component.displayName = `Animated(${displayName})`\n    return Component\n  }\n\n  eachProp(components, (Component, key) => {\n    if (is.arr(components)) {\n      key = getDisplayName(Component)!\n    }\n    animated[key] = animated(Component)\n  })\n\n  return {\n    animated,\n  }\n}\n\nconst getDisplayName = (arg: AnimatableComponent) =>\n  is.str(arg)\n    ? arg\n    : arg && is.str(arg.displayName)\n    ? arg.displayName\n    : (is.fun(arg) && arg.name) || null\n","import * as React from 'react'\nimport { forwardRef, useRef, Ref, useCallback, useEffect } from 'react'\nimport {\n  is,\n  each,\n  raf,\n  useForceUpdate,\n  useOnce,\n  FluidEvent,\n  FluidValue,\n  addFluidObserver,\n  removeFluidObserver,\n  useIsomorphicLayoutEffect,\n} from '@react-spring/shared'\nimport { ElementType } from '@react-spring/types'\n\nimport { AnimatedObject } from './AnimatedObject'\nimport { TreeContext } from './context'\nimport { HostConfig } from './createHost'\n\nexport type AnimatableComponent = string | Exclude<ElementType, string>\n\nexport const withAnimated = (Component: any, host: HostConfig) => {\n  const hasInstance: boolean =\n    // Function components must use \"forwardRef\" to avoid being\n    // re-rendered on every animation frame.\n    !is.fun(Component) ||\n    (Component.prototype && Component.prototype.isReactComponent)\n\n  return forwardRef((givenProps: any, givenRef: Ref<any>) => {\n    const instanceRef = useRef<any>(null)\n\n    // The `hasInstance` value is constant, so we can safely avoid\n    // the `useCallback` invocation when `hasInstance` is false.\n    const ref =\n      hasInstance &&\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      useCallback(\n        (value: any) => {\n          instanceRef.current = updateRef(givenRef, value)\n        },\n        [givenRef]\n      )\n\n    const [props, deps] = getAnimatedState(givenProps, host)\n\n    const forceUpdate = useForceUpdate()\n\n    const callback = () => {\n      const instance = instanceRef.current\n      if (hasInstance && !instance) {\n        // Either this component was unmounted before changes could be\n        // applied, or the wrapped component forgot to forward its ref.\n        return\n      }\n\n      const didUpdate = instance\n        ? host.applyAnimatedValues(instance, props.getValue(true))\n        : false\n\n      // Re-render the component when native updates fail.\n      if (didUpdate === false) {\n        forceUpdate()\n      }\n    }\n\n    const observer = new PropsObserver(callback, deps)\n\n    const observerRef = useRef<PropsObserver>()\n    useIsomorphicLayoutEffect(() => {\n      observerRef.current = observer\n\n      // Observe the latest dependencies.\n      each(deps, dep => addFluidObserver(dep, observer))\n\n      return () => {\n        // Stop observing previous dependencies.\n        if (observerRef.current) {\n          each(observerRef.current.deps, dep =>\n            removeFluidObserver(dep, observerRef.current!)\n          )\n          raf.cancel(observerRef.current.update)\n        }\n      }\n    })\n\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    useEffect(callback, [])\n    // Stop observing on unmount.\n    useOnce(() => () => {\n      const observer = observerRef.current!\n      each(observer.deps, dep => removeFluidObserver(dep, observer))\n    })\n\n    const usedProps = host.getComponentProps(props.getValue())\n    return <Component {...usedProps} ref={ref} />\n  })\n}\n\nclass PropsObserver {\n  constructor(readonly update: () => void, readonly deps: Set<FluidValue>) {}\n  eventObserved(event: FluidEvent) {\n    if (event.type == 'change') {\n      raf.write(this.update)\n    }\n  }\n}\n\ntype AnimatedState = [props: AnimatedObject, dependencies: Set<FluidValue>]\n\nfunction getAnimatedState(props: any, host: HostConfig): AnimatedState {\n  const dependencies = new Set<FluidValue>()\n  TreeContext.dependencies = dependencies\n\n  // Search the style for dependencies.\n  if (props.style)\n    props = {\n      ...props,\n      style: host.createAnimatedStyle(props.style),\n    }\n\n  // Search the props for dependencies.\n  props = new AnimatedObject(props)\n\n  TreeContext.dependencies = null\n  return [props, dependencies]\n}\n\nfunction updateRef<T>(ref: Ref<T>, value: T) {\n  if (ref) {\n    if (is.fun(ref)) ref(value)\n    else (ref as any).current = value\n  }\n  return value\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}